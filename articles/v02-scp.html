<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>scp for single-cell proteomics analyses • QFeaturesScpWorkshop2021</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="scp for single-cell proteomics analyses">
<meta property="og:description" content="QFeaturesScpWorkshop2021">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">QFeaturesScpWorkshop2021</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/v01-QFeatures.html">The QFeatures class</a>
    </li>
    <li>
      <a href="../articles/v02-scp.html">scp for single-cell proteomics analyses</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/lgatto/QFeaturesScpWorkshop2021">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="v02-scp_files/header-attrs-2.9/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>scp for single-cell proteomics analyses</h1>
                        <h4 class="author">Laurent Gatto and Christophe Vanderaa</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/lgatto/QFeaturesScpWorkshop2021/blob/master/vignettes/v02-scp.Rmd"><code>vignettes/v02-scp.Rmd</code></a></small>
      <div class="hidden name"><code>v02-scp.Rmd</code></div>

    </div>

    
    
<p><strong>Last modified:</strong> 2021-08-02 08:50:30<br><strong>Compiled</strong>: Mon Aug 2 11:10:43 2021</p>
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>Mass spectrometry (MS)-based single-cell proteomics (SCP) is emerging thanks to several recent technological advances in sample preparation, liquid chromatography (LC) and MS (see <span class="citation">Kelly (2020)</span> for a comprehensive review). The improvements tackle the issues encountered when dealing with small sample amounts and focus on:</p>
<ul>
<li>Reducing sample loss</li>
<li>Increasing sensitivity and quantification accuracy</li>
<li>Increasing acquisition throughput</li>
</ul>
<p>Two main strategies have currently been developed. On the one hand, label-free protocols acquire one single cell per MS run leading to accurate quantification but low sensitivity and throughput. On the other hand, label-based protocols multiplex several single-cell samples in one MS run leading to higher throughput (1000 cells per week). Another advantage of label-based protocols is the inclusion of a carrier sample, that is a sample containing between tens to hundreds of cells. Including a carrier increases sensitivity thanks to increased sample material, but at the cost of decreased quantification accuracy due to chemical noise (linked to sample labelling) and competition between the single-cell samples and the carrier sample during MS acquisition.</p>
<p>Although the <code>scp</code> package can handle the data acquired from the two strategies, the exercise of this vignette will focus on the multiplexed strategy developed by <span class="citation">Specht et al. (2021)</span>, called SCoPE2. An overview of the acquisition and data processing pipeline is depicted below.</p>
<div class="figure">
<img src="figs/SCoPE2_pipeline.png" alt="Main steps of the SCoPE2 data acquisition and processing pipeline." width="80%"><p class="caption">
Main steps of the SCoPE2 data acquisition and processing pipeline.
</p>
</div>
</div>
<div id="the-scp-data-framework" class="section level1">
<h1 class="hasAnchor">
<a href="#the-scp-data-framework" class="anchor"></a>The <code>scp</code> data framework</h1>
<p>SCP data is very similar to bulk proteomics data with the exception that the PSM data may be composed of tens to hundreds of separate acquisition runs. The <code>QFeatures</code> class is able to store this acquisition structure by considering each MS run as a separate assay. Because the assays hold information about single cells, they are stored as <code>SingleCellExperiment</code> objects (<span class="citation">Lun and Risso (2020)</span>) to create a direct interface to existing Bioconductor packages. Performing downstream analyses (such as dimension reduction, clustering, finding markers) very easy. The links between related features across different assays are also stored to facilitate manipulation and visualization of of PSM, peptide and protein data as we go along with the processing workflow.</p>
<div class="figure">
<img src="figs/SCP_framework.png" alt="Conceptual overview of a `QFeatures` object containing SCP data. Each assay is stored as a `SingleCellExperiment` object." width="80%"><p class="caption">
Conceptual overview of a <code>QFeatures</code> object containing SCP data. Each assay is stored as a <code>SingleCellExperiment</code> object.
</p>
</div>
</div>
<div id="the-scp-package" class="section level1">
<h1 class="hasAnchor">
<a href="#the-scp-package" class="anchor"></a>The <code>scp</code> package</h1>
<p>The general workflow for processing SCP data is very similar to the workflow for bulk proteomics that we presented in the previous vignette. Therefore, the <code>QFeatures</code> package already contains most of the tools required for the processing of SCP data. The <code>scp</code> package implements the missing functions that are specifically designed for dealing with SCP data. Below, we provide the list of functions from <code>scp</code> that extend the <code>QFeatures</code> functions:</p>
<ul>
<li>
<code>readSCP</code>: this is the main feature of the <code>scp</code> package. It loads and formats standard data tables into <code>QFeatures</code> objects ready for data processing.</li>
<li>
<code>aggregateFeaturesOverAssays</code>: extends <code>aggregateFeatures</code> to allow streamlined aggregation over multiple assays</li>
<li>
<code>computeSCR</code>: compute the sample over carrier ratio (SCR), a useful metric for feature QC</li>
<li>
<code>divideByReference</code>: divide columns by a reference column</li>
<li>
<code>medianCVperCell</code>: compute the median coefficient of variation (CV) per cell, a useful metric for single-cell QC</li>
<li>
<code>normalizeSCP</code>: extends <code><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-processing.html">QFeatures::normalize</a></code> to <code>SingleCellExperiment</code> objects</li>
<li>
<code>pep2qvalue</code>: compute q-values from posterior error probabilities</li>
<li>
<code>rowDataToDF</code>: extract the <code>rowData</code> of a <code>QFeatures</code> object to a <code>DataFrame</code>
</li>
</ul>
<p>You will be able to test those functions in the <strong>exercise</strong> later in this vignette.</p>
</div>
<div id="load-scp-data" class="section level1">
<h1 class="hasAnchor">
<a href="#load-scp-data" class="anchor"></a>Load SCP data</h1>
<p>There are two input tables required for starting an analysis with <code>scp</code>:</p>
<ol style="list-style-type: decimal">
<li>The feature data</li>
<li>The sample data</li>
</ol>
<div id="feature-data" class="section level2">
<h2 class="hasAnchor">
<a href="#feature-data" class="anchor"></a>Feature data</h2>
<p>The feature data are generated after the identification and quantification of the MS spectra by a pre-processing software such as MaxQuant, ProteomeDiscoverer or MSFragger (the <a href="https://en.wikipedia.org/wiki/List_of_mass_spectrometry_software">list</a> of available software is actually much longer). We will here use as an example a data table that has been generated by MaxQuant. The table is available from the <code>scp</code> package and is called <code>mqScpData</code> (for MaxQuant-generated SCP data).</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://UCLouvain-CBIO.github.io/scp">scp</a></span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"mqScpData"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">mqScpData</span><span class="op">)</span>
<span class="co">## [1] 1361  149</span></code></pre></div>
<p>In this toy example, there are 1361 rows corresponding to features (quantified PSMs) and 149 columns corresponding to different data fields recorded by MaxQuant during the processing of the MS spectra. The columns can be divided into three categories:</p>
<ul>
<li>Columns holding feature quantifications</li>
<li>Columns holding feature metadata</li>
<li>Columns holding MS run metadata</li>
</ul>
<div id="feature-quantifications" class="section level3">
<h3 class="hasAnchor">
<a href="#feature-quantifications" class="anchor"></a>Feature quantifications</h3>
<p>The quantification data can be composed of one (in case of label-free acquisition) up to 16 columns (in case of TMT-16 multiplexing). The columns holding the quantification start with <code>Reporter.intensity.</code> followed by a number.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">quantCols</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html">grep</a></span><span class="op">(</span><span class="st">"Reporter.intensity.\\d"</span>, <span class="fu"><a href="https://rdrr.io/r/base/colnames.html">colnames</a></span><span class="op">(</span><span class="va">mqScpData</span><span class="op">)</span>, value <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>
<span class="co">##  [1] "Reporter.intensity.1"  "Reporter.intensity.2"  "Reporter.intensity.3" </span>
<span class="co">##  [4] "Reporter.intensity.4"  "Reporter.intensity.5"  "Reporter.intensity.6" </span>
<span class="co">##  [7] "Reporter.intensity.7"  "Reporter.intensity.8"  "Reporter.intensity.9" </span>
<span class="co">## [10] "Reporter.intensity.10" "Reporter.intensity.11" "Reporter.intensity.12"</span>
<span class="co">## [13] "Reporter.intensity.13" "Reporter.intensity.14" "Reporter.intensity.15"</span>
<span class="co">## [16] "Reporter.intensity.16"</span></code></pre></div>
<p>As you may notice, the example data was acquired using a TMT-16 protocol since we retrieve 16 quantification columns. Actually, some runs were acquired using a TMT-11 protocol (11 labels) but we will come back to this later.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">mqScpData</span><span class="op">[</span>, <span class="va">quantCols</span><span class="op">]</span><span class="op">)</span>
<span class="co">##   Reporter.intensity.1 Reporter.intensity.2 Reporter.intensity.3</span>
<span class="co">## 1                61251               501.71               3731.3</span>
<span class="co">## 2                58648              1099.80               2837.7</span>
<span class="co">## 3               150350              3705.00               9361.0</span>
<span class="co">## 4                27347               405.90               1525.2</span>
<span class="co">## 5                84035               583.09               4092.3</span>
<span class="co">## 6                44895               700.23               2283.0</span>
<span class="co">##   Reporter.intensity.4 Reporter.intensity.5 Reporter.intensity.6</span>
<span class="co">## 1              1643.30               871.84               981.87</span>
<span class="co">## 2               494.32               349.26              1030.50</span>
<span class="co">## 3                 0.00              1945.40              1188.60</span>
<span class="co">## 4                 0.00                 0.00               318.74</span>
<span class="co">## 5               530.13               718.13              2204.50</span>
<span class="co">## 6              1109.60                 0.00               675.79</span>
<span class="co">##   Reporter.intensity.7 Reporter.intensity.8 Reporter.intensity.9</span>
<span class="co">## 1              1200.10               939.06              1457.50</span>
<span class="co">## 2                 0.00              1214.10               800.58</span>
<span class="co">## 3              1574.00              2302.10              2176.10</span>
<span class="co">## 4                 0.00               519.81                 0.00</span>
<span class="co">## 5               960.51               453.77              1188.40</span>
<span class="co">## 6                 0.00               809.38               668.88</span>
<span class="co">##   Reporter.intensity.10 Reporter.intensity.11 Reporter.intensity.12</span>
<span class="co">## 1               1329.80                981.83                    NA</span>
<span class="co">## 2                807.79                391.38                    NA</span>
<span class="co">## 3               1399.50               1307.50                2192.4</span>
<span class="co">## 4                507.23                370.79                    NA</span>
<span class="co">## 5                740.99                  0.00                    NA</span>
<span class="co">## 6               1467.50                901.38                    NA</span>
<span class="co">##   Reporter.intensity.13 Reporter.intensity.14 Reporter.intensity.15</span>
<span class="co">## 1                    NA                    NA                    NA</span>
<span class="co">## 2                    NA                    NA                    NA</span>
<span class="co">## 3                1791.4                1727.5                2157.3</span>
<span class="co">## 4                    NA                    NA                    NA</span>
<span class="co">## 5                    NA                    NA                    NA</span>
<span class="co">## 6                    NA                    NA                    NA</span>
<span class="co">##   Reporter.intensity.16</span>
<span class="co">## 1                    NA</span>
<span class="co">## 2                    NA</span>
<span class="co">## 3                  1398</span>
<span class="co">## 4                    NA</span>
<span class="co">## 5                    NA</span>
<span class="co">## 6                    NA</span></code></pre></div>
</div>
<div id="feature-metadata" class="section level3">
<h3 class="hasAnchor">
<a href="#feature-metadata" class="anchor"></a>Feature metadata</h3>
<p>Most columns in the <code>mqScpData</code> table contain information used or generated during the identification of the MS spectra. For instance, you may find the charge of the parent ion, the score and probability of a correct match between the MS spectrum and a peptide sequence, the sequence of the best matching peptide, its length, its modifications, the retention time of the peptide on the LC, the protein(s) the peptide originates from and much more.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">mqScpData</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Charge"</span>, <span class="st">"Score"</span>, <span class="st">"PEP"</span>, <span class="st">"Sequence"</span>, <span class="st">"Length"</span>,
                   <span class="st">"Retention.time"</span>, <span class="st">"Proteins"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>
<span class="co">##   Charge  Score        PEP    Sequence Length Retention.time</span>
<span class="co">## 1      2 41.029 5.2636e-04   ATNFLAHEK      9         65.781</span>
<span class="co">## 2      2 44.349 5.8789e-04   ATNFLAHEK      9         63.787</span>
<span class="co">## 3      2 51.066 4.0315e-24 SHTILLVQPTK     11         71.884</span>
<span class="co">## 4      2 63.816 4.7622e-06 SHTILLVQPTK     11         68.633</span>
<span class="co">## 5      2 74.464 6.8709e-09 SHTILLVQPTK     11         71.946</span>
<span class="co">## 6      2 41.502 5.3705e-02     SLVIPEK      7         76.204</span>
<span class="co">##               Proteins</span>
<span class="co">## 1 sp|P29692|EF1D_HUMAN</span>
<span class="co">## 2 sp|P29692|EF1D_HUMAN</span>
<span class="co">## 3  sp|P84090|ERH_HUMAN</span>
<span class="co">## 4  sp|P84090|ERH_HUMAN</span>
<span class="co">## 5  sp|P84090|ERH_HUMAN</span>
<span class="co">## 6 sp|P62269|RS18_HUMAN</span></code></pre></div>
</div>
<div id="ms-run-metadata" class="section level3">
<h3 class="hasAnchor">
<a href="#ms-run-metadata" class="anchor"></a>MS run metadata</h3>
<p>This type of metadata is related to the MS instrument. In MaxQuant, only the file name generated by the MS instrument is stored. There is one file for each MS run, hence the file name can be used as a batch identifier.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="va">mqScpData</span><span class="op">$</span><span class="va">Raw.file</span><span class="op">)</span>
<span class="co">## [1] "190321S_LCA10_X_FP97AG"        "190222S_LCA9_X_FP94BM"        </span>
<span class="co">## [3] "190914S_LCB3_X_16plex_Set_21"  "190321S_LCA10_X_FP97_blank_01"</span></code></pre></div>
<p>The 1361 PSM were found across 4 MS runs. While these 4 runs are contained in a single table, we will split them in separate assay when building the <code>QFeautres</code> object.</p>
</div>
</div>
<div id="sample-data" class="section level2">
<h2 class="hasAnchor">
<a href="#sample-data" class="anchor"></a>Sample data</h2>
<p>Next to the quantification data and the feature data, sample metadata contains the experimental design generated by the researcher. The rows of sample metadata correspond to a sample in the experiment and the columns correspond to the available information about the sample. We will here use the second example table provided in <code>scp</code>:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"sampleAnnotation"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">sampleAnnotation</span><span class="op">)</span>
<span class="co">##                Raw.file              Channel SampleType lcbatch sortday digest</span>
<span class="co">## 1 190222S_LCA9_X_FP94BM Reporter.intensity.1    Carrier    LCA9      s8      N</span>
<span class="co">## 2 190222S_LCA9_X_FP94BM Reporter.intensity.2  Reference    LCA9      s8      N</span>
<span class="co">## 3 190222S_LCA9_X_FP94BM Reporter.intensity.3     Unused    LCA9      s8      N</span>
<span class="co">## 4 190222S_LCA9_X_FP94BM Reporter.intensity.4   Monocyte    LCA9      s8      N</span>
<span class="co">## 5 190222S_LCA9_X_FP94BM Reporter.intensity.5      Blank    LCA9      s8      N</span>
<span class="co">## 6 190222S_LCA9_X_FP94BM Reporter.intensity.6   Monocyte    LCA9      s8      N</span></code></pre></div>
<p>This table may contain any information about the samples. For example, useful information could be the type of sample that is analysed, an <em>apriori</em> known phenotype, the MS batch, the acquisition date, MS settings used to acquire the sample, the LC batch, the sample preparation batch, … <code>scp</code> <strong>requires</strong> 2 specific fields in the sample metadata:</p>
<ol style="list-style-type: decimal">
<li>One column containing the MS run names (<code>Raw.file</code> in this case). It must have the same name as the name of the column containing the MS run names in the quantification table. This will allow <code>scp</code> to correctly match and split data that were acquired separately. This is illustrated below by the linked circles.</li>
<li>One column that tells <code>scp</code> which column in the feature data holds the quantification of the corresponding sample. This is illustrated below by the arrow.</li>
</ol>
<div class="figure">
<img src="figs/readSCP_relation.png" alt="Linking the sample data to the feature data." width="50%"><p class="caption">
Linking the sample data to the feature data.
</p>
</div>
</div>
<div id="readscp" class="section level2">
<h2 class="hasAnchor">
<a href="#readscp" class="anchor"></a><code>readSCP</code>
</h2>
<p><code>readSCP</code> is the function that converts the sample and the feature data into a <code>QFeatures</code> object following the data structure described above, that is storing the data belonging to each MS batch in a separate <code>SingleCellExperiment</code> object. We therefore provide the feature data, the sample data to the function as well as the name of the column that holds the batch name in both tables and the name of the column in the sample data that points to the quantification columns in the feature data. We also add an (optional) suffix to the sample names to remind that samples were labelled using 16 different TMT. Finally, another optional argument is to remove empty samples (<code>removeEmptyCols = TRUE</code>). We do this because one run was acquired using TMT-16 and the three other runs were acquired using TMT-11, meaning that the quantification columns for labels 12 to 16 are empty for all except one batch.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/readSCP.html">readSCP</a></span><span class="op">(</span>featureData <span class="op">=</span> <span class="va">mqScpData</span>,
               colData <span class="op">=</span> <span class="va">sampleAnnotation</span>,
               batchCol <span class="op">=</span> <span class="st">"Raw.file"</span>,
               channelCol <span class="op">=</span> <span class="st">"Channel"</span>,
               suffix <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"_TMT"</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">16</span><span class="op">)</span>,
               removeEmptyCols <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">## Loading data as a 'SingleCellExperiment' object</span>
<span class="co">## Splitting data based on 'Raw.file'</span>
<span class="co">## Formatting sample metadata (colData)</span>
<span class="co">## Formatting data as a 'QFeatures' object</span></code></pre></div>
<p>As prompted by the function, the feature data is converted to a <code>SingleCellExperiment</code> object then split according to the batch structure. This means that we should have as many assays than batches:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">## An instance of class QFeatures containing 4 assays:</span>
<span class="co">##  [1] 190222S_LCA9_X_FP94BM: SingleCellExperiment with 395 rows and 11 columns </span>
<span class="co">##  [2] 190321S_LCA10_X_FP97_blank_01: SingleCellExperiment with 109 rows and 11 columns </span>
<span class="co">##  [3] 190321S_LCA10_X_FP97AG: SingleCellExperiment with 487 rows and 11 columns </span>
<span class="co">##  [4] 190914S_LCB3_X_16plex_Set_21: SingleCellExperiment with 370 rows and 16 columns</span></code></pre></div>
<p>Indeed, we can see that the object returned by <code>readSCP</code> is a <code>QFeatures</code> object containing 4 <code>SingleCellExperiment</code> assays that have been named after the 4 MS batches. Each assay contains either 11 or 16 columns (samples) depending on the TMT labelling strategy and a variable number of rows (quantified PSMs). Each piece of information can easily be retrieved thanks to the <code>Qfeatures</code> architectures. As mentioned in the previous vignette, sample data is retrieved from the <code>colData</code>. Note that unique sample names were automatically generated by combining the batch name and the suffix provided to <code>readSCP</code>:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">colData</span><span class="op">(</span><span class="va">scp</span><span class="op">)</span>
<span class="co">## DataFrame with 49 rows and 6 columns</span>
<span class="co">##                                         Raw.file       Channel  SampleType</span>
<span class="co">##                                      &lt;character&gt;   &lt;character&gt; &lt;character&gt;</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT1         190222S_LC... Reporter.i...     Carrier</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT2         190222S_LC... Reporter.i...   Reference</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT3         190222S_LC... Reporter.i...      Unused</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT4         190222S_LC... Reporter.i...    Monocyte</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT5         190222S_LC... Reporter.i...       Blank</span>
<span class="co">## ...                                          ...           ...         ...</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT12 190914S_LC... Reporter.i...  Macrophage</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT13 190914S_LC... Reporter.i...  Macrophage</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT14 190914S_LC... Reporter.i...  Macrophage</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT15 190914S_LC... Reporter.i...  Macrophage</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT16 190914S_LC... Reporter.i...  Macrophage</span>
<span class="co">##                                        lcbatch     sortday      digest</span>
<span class="co">##                                    &lt;character&gt; &lt;character&gt; &lt;character&gt;</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT1                LCA9          s8           N</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT2                LCA9          s8           N</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT3                LCA9          s8           N</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT4                LCA9          s8           N</span>
<span class="co">## 190222S_LCA9_X_FP94BM_TMT5                LCA9          s8           N</span>
<span class="co">## ...                                        ...         ...         ...</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT12        LCB3          s9           R</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT13        LCB3          s9           R</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT14        LCB3          s9           R</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT15        LCB3          s9           R</span>
<span class="co">## 190914S_LCB3_X_16plex_Set_21_TMT16        LCB3          s9           R</span></code></pre></div>
<p>The feature metadata is retrieved from the <code>rowData</code>. Since the feature metadata is specific to each assay, we need to tell from which assay we want to get the <code>rowData</code>:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">rowData</span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"190222S_LCA9_X_FP94BM"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>
<span class="co">## DataFrame with 395 rows and 5 columns</span>
<span class="co">##                   uid      Sequence    Length Modifications Modified.sequence</span>
<span class="co">##           &lt;character&gt;   &lt;character&gt; &lt;integer&gt;   &lt;character&gt;       &lt;character&gt;</span>
<span class="co">## PSM2    _(Acetyl (...     ATNFLAHEK         9 Acetyl (Pr...     _(Acetyl (...</span>
<span class="co">## PSM4    _(Acetyl (... SHTILLVQPT...        11 Acetyl (Pr...     _(Acetyl (...</span>
<span class="co">## PSM6    _(Acetyl (...       SLVIPEK         7 Acetyl (Pr...     _(Acetyl (...</span>
<span class="co">## PSM9    _AAGLALK_ ...       AAGLALK         7    Unmodified         _AAGLALK_</span>
<span class="co">## PSM12   _AALSAGK_ ...       AALSAGK         7    Unmodified         _AALSAGK_</span>
<span class="co">## ...               ...           ...       ...           ...               ...</span>
<span class="co">## PSM1242 _YSQVLANGL... YSQVLANGLD...        12    Unmodified     _YSQVLANGL...</span>
<span class="co">## PSM1244 _YVLGPAVR_...      YVLGPAVR         8    Unmodified        _YVLGPAVR_</span>
<span class="co">## PSM1247 _YYPTEDVPR...     YYPTEDVPR         9    Unmodified     _YYPTEDVPR...</span>
<span class="co">## PSM1249 _YYSVNSR_ ...       YYSVNSR         7    Unmodified         _YYSVNSR_</span>
<span class="co">## PSM1252 _YYTVFDR_ ...       YYTVFDR         7    Unmodified         _YYTVFDR_</span></code></pre></div>
<p>Finally, we can also retrieve the quantification matrix for an assay of interest:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span>, <span class="st">"190222S_LCA9_X_FP94BM"</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>
<span class="co">##       190222S_LCA9_X_FP94BM_TMT1 190222S_LCA9_X_FP94BM_TMT2</span>
<span class="co">## PSM2                       58648                    1099.80</span>
<span class="co">## PSM4                       27347                     405.90</span>
<span class="co">## PSM6                       44895                     700.23</span>
<span class="co">## PSM9                      122070                    1153.50</span>
<span class="co">## PSM12                      58605                     895.25</span>
<span class="co">##       190222S_LCA9_X_FP94BM_TMT3 190222S_LCA9_X_FP94BM_TMT4</span>
<span class="co">## PSM2                      2837.7                     494.32</span>
<span class="co">## PSM4                      1525.2                       0.00</span>
<span class="co">## PSM6                      2283.0                    1109.60</span>
<span class="co">## PSM9                      7361.9                    1732.30</span>
<span class="co">## PSM12                     2763.8                     867.82</span>
<span class="co">##       190222S_LCA9_X_FP94BM_TMT5</span>
<span class="co">## PSM2                      349.26</span>
<span class="co">## PSM4                        0.00</span>
<span class="co">## PSM6                        0.00</span>
<span class="co">## PSM9                     1515.60</span>
<span class="co">## PSM12                    1050.30</span></code></pre></div>
</div>
</div>
<div id="the-scpdata-package" class="section level1">
<h1 class="hasAnchor">
<a href="#the-scpdata-package" class="anchor"></a>The <code>scpdata</code> package</h1>
<p>Next to <code>scp</code>, we also developed <code>scpdata</code>, a data package that disseminates published SCP data sets formatted using the <code>scp</code> data structure. The package heavily relies on the <a href="https://bioconductor.org/packages/release/bioc/html/ExperimentHub.html"><code>ExperimentHub</code></a> infrastructure. This package is an ideal platform for data sharing and promotes for open and reproducible science in SCP, it facilitates the access for developers to SCP data to build and benchmark new methodologies and it facilitates the access for new users to data in the context of training and demonstration (like this workshop).</p>
<p>After loading the package, you can have a look at the available datasets by running:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">scpdata</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/pkg/scpdata/man/scpdata.html">scpdata</a></span><span class="op">(</span><span class="op">)</span>
<span class="co">## DataFrame with 12 rows and 15 columns</span>
<span class="co">##                title  dataprovider       species taxonomyid      genome</span>
<span class="co">##          &lt;character&gt;   &lt;character&gt;   &lt;character&gt;  &lt;integer&gt; &lt;character&gt;</span>
<span class="co">## EH3899 specht2019... SlavovLab ... Homo sapie...       9606          NA</span>
<span class="co">## EH3900 specht2019... SlavovLab ... Homo sapie...       9606          NA</span>
<span class="co">## EH3901 dou2019_ly...       MassIVE Homo sapie...       9606          NA</span>
<span class="co">## EH3902 dou2019_mo...       MassIVE Mus muscul...      10090          NA</span>
<span class="co">## EH3903 dou2019_bo...       MassIVE Mus muscul...      10090          NA</span>
<span class="co">## ...              ...           ...           ...        ...         ...</span>
<span class="co">## EH3906 zhu2018NC_...         PRIDE Homo sapie...       9606          NA</span>
<span class="co">## EH3907 zhu2018NC_...         PRIDE Homo sapie...       9606          NA</span>
<span class="co">## EH3908    cong2020AC         PRIDE Homo sapie...       9606          NA</span>
<span class="co">## EH3909     zhu2019EL         PRIDE Gallus gal...       9031          NA</span>
<span class="co">## EH6011 liang2020_...         PRIDE Homo sapie...       9606          NA</span>
<span class="co">##          description coordinate_1_based    maintainer rdatadateadded</span>
<span class="co">##          &lt;character&gt;          &lt;integer&gt;   &lt;character&gt;    &lt;character&gt;</span>
<span class="co">## EH3899 SCP expres...                  1 Christophe...     2020-11-05</span>
<span class="co">## EH3900 SCP expres...                  1 Christophe...     2020-11-05</span>
<span class="co">## EH3901 SCP expres...                  1 Christophe...     2020-11-05</span>
<span class="co">## EH3902 SCP expres...                  1 Christophe...     2020-11-05</span>
<span class="co">## EH3903 SCP expres...                  1 Christophe...     2020-11-05</span>
<span class="co">## ...              ...                ...           ...            ...</span>
<span class="co">## EH3906 Near SCP e...                  1 Christophe...     2020-11-05</span>
<span class="co">## EH3907 Near SCP e...                  1 Christophe...     2020-11-05</span>
<span class="co">## EH3908 SCP expres...                  1 Christophe...     2020-11-05</span>
<span class="co">## EH3909 SCP expres...                  1 Christophe...     2020-11-05</span>
<span class="co">## EH6011 Expression...                  1 Christophe...     2021-04-27</span>
<span class="co">##        preparerclass                                          tags  rdataclass</span>
<span class="co">##          &lt;character&gt;                                        &lt;list&gt; &lt;character&gt;</span>
<span class="co">## EH3899       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## EH3900       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## EH3901       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## EH3902       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## EH3903       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## ...              ...                                           ...         ...</span>
<span class="co">## EH3906       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## EH3907       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## EH3908       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## EH3909       scpdata Experiment...,Expression...,Experiment...,...   QFeatures</span>
<span class="co">## EH6011       scpdata      Expression...,MassSpectr...,Proteome,...   QFeatures</span>
<span class="co">##            rdatapath     sourceurl  sourcetype</span>
<span class="co">##          &lt;character&gt;   &lt;character&gt; &lt;character&gt;</span>
<span class="co">## EH3899 scpdata/sp... https://sc...         CSV</span>
<span class="co">## EH3900 scpdata/sp... https://sc...         CSV</span>
<span class="co">## EH3901 scpdata/do... ftp://mass...    XLS/XLSX</span>
<span class="co">## EH3902 scpdata/do... ftp://mass...    XLS/XLSX</span>
<span class="co">## EH3903 scpdata/do... ftp://mass...    XLS/XLSX</span>
<span class="co">## ...              ...           ...         ...</span>
<span class="co">## EH3906 scpdata/zh... ftp://ftp....         TXT</span>
<span class="co">## EH3907 scpdata/zh... ftp://ftp....         TXT</span>
<span class="co">## EH3908 scpdata/co... ftp://ftp....         TXT</span>
<span class="co">## EH3909 scpdata/zh... ftp://ftp....         TXT</span>
<span class="co">## EH6011 scpdata/li... ftp://ftp....         TXT</span></code></pre></div>
<p>For instance, loading the data sets published in <span class="citation">Zhu et al. (2019)</span> is as simple as calling the title of the data set:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/scpdata/man/zhu2019EL.html">zhu2019EL</a></span><span class="op">(</span><span class="op">)</span>
<span class="co">## An instance of class QFeatures containing 62 assays:</span>
<span class="co">##  [1] 1H1a: SingleCellExperiment with 152 rows and 1 columns </span>
<span class="co">##  [2] 1H1b: SingleCellExperiment with 267 rows and 1 columns </span>
<span class="co">##  [3] 1H1c: SingleCellExperiment with 128 rows and 1 columns </span>
<span class="co">##  ...</span>
<span class="co">##  [60] 2N0c: SingleCellExperiment with 61 rows and 1 columns </span>
<span class="co">##  [61] peptides: SingleCellExperiment with 3444 rows and 60 columns </span>
<span class="co">##  [62] proteins: SingleCellExperiment with 840 rows and 60 columns</span></code></pre></div>
</div>
<div id="reproduce-a-published-analysis" class="section level1">
<h1 class="hasAnchor">
<a href="#reproduce-a-published-analysis" class="anchor"></a>Reproduce a published analysis</h1>
<p>As a use-case, we will reproduce the analysis of the SCoPE2 data published in <span class="citation">Specht et al. (2021)</span>. SCoPE2 is the first published SCP protocol that has been used to profile thousands of proteins in thousands of single-cells. This is a technical milestone for the field and it opens the door for a fine-grain understanding of biological processes at the protein level.</p>
<p>Along their acquisition protocol, the authors have also provided an <a href="https://github.com/SlavovLab/SCoPE2/blob/8780805f69f7547a2f3b592d3614b649179dfc4e/code/SCoPE2_analysis.R">R script</a> to reproduce their data processing. The code is hard to read and built from scratch. We have used <code>scp</code> to standardize this workflow (<span class="citation">Vanderaa and Gatto (2021)</span>) and reproduce the results using code that can easily be adapted to other data sets. The outline of the workflow is shown below.</p>
<div class="figure">
<img src="figs/SCoPE2_workflow.png" alt="Workflow describing the main steps performed by Specht et al. to process the SCP data. Figure taken from @Vanderaa2021-xd" width="80%"><p class="caption">
Workflow describing the main steps performed by Specht et al. to process the SCP data. Figure taken from <span class="citation">Vanderaa and Gatto (2021)</span>
</p>
</div>
<p>The replication analysis on the full data set is provided in <a href="https://uclouvain-cbio.github.io/SCP.replication/articles/SCoPE2.html">another vignette</a>.</p>
<div id="import-the-data" class="section level2">
<h2 class="hasAnchor">
<a href="#import-the-data" class="anchor"></a>Import the data</h2>
<p>In a previous section we have shown how to format the feature and sample tables to a <code>Qfeatures</code> object for a small subset of the SCoPE2 data set. We will here import the data directly from <code>scpdata</code> to gain some time.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/scpdata/man/specht2019v3.html">specht2019v3</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span>
<span class="co">## An instance of class QFeatures containing 179 assays:</span>
<span class="co">##  [1] 190222S_LCA9_X_FP94AA: SingleCellExperiment with 2777 rows and 11 columns </span>
<span class="co">##  [2] 190222S_LCA9_X_FP94AB: SingleCellExperiment with 4348 rows and 11 columns </span>
<span class="co">##  [3] 190222S_LCA9_X_FP94AC: SingleCellExperiment with 4917 rows and 11 columns </span>
<span class="co">##  ...</span>
<span class="co">##  [177] 191110S_LCB7_X_APNOV16plex2_Set_9: SingleCellExperiment with 4934 rows and 16 columns </span>
<span class="co">##  [178] peptides: SingleCellExperiment with 9354 rows and 1490 columns </span>
<span class="co">##  [179] proteins: SingleCellExperiment with 3042 rows and 1490 columns</span></code></pre></div>
<p>The data set provides 177 assays containing the PSM data, but also two assays that contain the peptide and protein data generated by the authors in the original work.</p>
<p>First, to reduce the computational burden we will focus on part of the data. The samples that were acquired in 4 chromatographic batches and we will run this example on the batch called (<code>LCB3</code>).</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="va">scp</span><span class="op">[</span>, , <span class="fu"><a href="https://rdrr.io/r/base/grep.html">grepl</a></span><span class="op">(</span><span class="st">"LCB3"</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">)</span><span class="op">]</span>
<span class="co">## Warning: 'experiments' dropped; see 'metadata'</span></code></pre></div>
</div>
<div id="before-starting-the-exercise" class="section level2">
<h2 class="hasAnchor">
<a href="#before-starting-the-exercise" class="anchor"></a>Before starting the exercise</h2>
<p>The remainder of the vignette includes a few exercises for you to have your hands on the functions in <code>QFeatures</code> and <code>scp</code>. We have hidden the solution under <code>Solution</code> ticks that you can click on to reveal a good answer (sometimes, several solution are possible but we provided only one).</p>
<p><strong>Important</strong>: while experimenting with the package, you might cause unwanted changes to your data. To avoid running the whole script at every mistake, we recommend you to save the data in a temporary variable before every exercise. For example:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tmp</span> <span class="op">&lt;-</span> <span class="va">scp</span></code></pre></div>
<p>As soon as you realize you made undesired changes, you can quickly revert to the previous state of the data by running</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="va">tmp</span></code></pre></div>
</div>
<div id="psm-quality-control" class="section level2">
<h2 class="hasAnchor">
<a href="#psm-quality-control" class="anchor"></a>PSM quality control</h2>
<p>This section will guide you through the filtering of low-quality features based on different metrics.</p>
<div id="filter-out-failed-runs-based-on-psm-content" class="section level3">
<h3 class="hasAnchor">
<a href="#filter-out-failed-runs-based-on-psm-content" class="anchor"></a>Filter out failed runs based on PSM content</h3>
<p>First, only the assays that have sufficient PSMs are kept. The authors keep an assay if it has over 500 PSMs. Before filtering, let’s first look at the distribution of the number of PSMs per assay.</p>
<p><strong>Exercise</strong>: Extract the number of rows (here PSMs) and the number of columns (TMT channels) of each assay using the <code>dims</code> function implemented in <code>QFeatures</code>.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">nPSMs</span> <span class="op">&lt;-</span> <span class="fu">dims</span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span></code></pre></div>
</details><p><br></p>
<p>Let’s have a look at the number of features that were identified in the different runs. The data visualization in this vignette is performed using the <code>ggplot2</code> function.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://ggplot2.tidyverse.org">"ggplot2"</a></span><span class="op">)</span>
<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span><span class="va">nPSMs</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">nPSMs</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_histogram.html">geom_histogram</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_vline</a></span><span class="op">(</span>xintercept <span class="op">=</span> <span class="fl">500</span><span class="op">)</span></code></pre></div>
<p><img src="v02-scp_files/figure-html/plot_dims-1.png" width="700"></p>
<p>No MS run failed in the LB3 batch. If some runs had failed, we could have subsetted the data taking advantage of the subsetting method of a <code>QFeatures</code> object.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="va">scp</span><span class="op">[</span>, , <span class="va">nPSMs</span> <span class="op">&gt;</span> <span class="fl">500</span><span class="op">]</span></code></pre></div>
</div>
<div id="filter-out-psms-with-high-false-discovery-rate" class="section level3">
<h3 class="hasAnchor">
<a href="#filter-out-psms-with-high-false-discovery-rate" class="anchor"></a>Filter out PSMs with high false discovery rate</h3>
<p>Next, the SCoPE2 workflow filters PSMs based on the false discovery rate (FDR) for identification. This will remove the PSMs that were matched by chance. The PSM data were already processed with DART-ID (<span class="citation">Chen, Franks, and Slavov (2019)</span>), a python software that updates the confidence in peptide identification using an Bayesian inference approach. DART-ID outputs for every PSM the updated posterior error probability (PEP). Filtering on the PEP is too conservative and it is rather advised to filter based on FDR (<span class="citation">Käll et al. (2008)</span>). To control for the FDR, we need to compute q-values, that correspond to the minimal FDR threshold that would still select the associated feature.</p>
<p>You can use the <code>pep2qvalue</code> function to easily compute q-values from the PEPs computed by MaxQuant or updated by DART-ID. In the SCoPE2 workflow, the features are selected based on the FDR at PSM level and at protein level. We here show to convert the PEP to q-values at PSM level. The DART-ID PEPs (<code>dart_PEP</code>) are automatically retrieved from the <code>rowData</code> of each assay. The function will store the computed q-values back in the <code>rowData</code> under <code>qvalue_psm</code>.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/pep2qvalue.html">pep2qvalue</a></span><span class="op">(</span><span class="va">scp</span>,
                  i <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span>,
                  PEP <span class="op">=</span> <span class="st">"dart_PEP"</span>,
                  rowDataName <span class="op">=</span> <span class="st">"qvalue_psm"</span><span class="op">)</span></code></pre></div>
<p><strong>Exercise</strong>: Try it yourself and convert the PEPs to protein-level q-values. Note that you will need to group the features by the protein identifiers in order to compute the q-values at proteins level.</p>
<details><summary>
Hint1
</summary>
Check the documentation (<code><a href="https://UCLouvain-CBIO.github.io/scp/reference/pep2qvalue.html">?pep2qvalue</a></code>) and look for the <code>groupBy</code> argument.
</details><details><summary>
Hint2
</summary>
Use <code>rowDataNames</code> on the <code>QFeatures</code> object to list all available grouping variables.
</details><details><summary>
Hint2
</summary>
If you run into errors, make sure to change the name of the <code>rowData</code> variable to something like <code>qvalue_protein</code>.
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/pep2qvalue.html">pep2qvalue</a></span><span class="op">(</span><span class="va">scp</span>,
                  i <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span>,
                  groupBy <span class="op">=</span> <span class="st">"protein"</span>,
                  PEP <span class="op">=</span> <span class="st">"dart_PEP"</span>,
                  rowDataName <span class="op">=</span> <span class="st">"qvalue_protein"</span><span class="op">)</span></code></pre></div>
</details><p><br></p>
<p>You can extract the q-values from the <code>rowData</code> of several assays using the <code>rbindRowData</code> function. It takes the <code>rowData</code> of interest and returns a single <code>DataFrame</code> table with all common variables. Let’s plot the q-values along with the DART-ID PEPs using <code>ggplot2</code> facets.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-class.html">rbindRowData</a></span><span class="op">(</span><span class="va">scp</span>, i <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="va">data.frame</span> <span class="op">%&gt;%</span>
    <span class="fu">pivot_longer</span><span class="op">(</span>cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"dart_PEP"</span>, <span class="st">"qvalue_psm"</span>, <span class="st">"qvalue_protein"</span><span class="op">)</span>,
                 names_to <span class="op">=</span> <span class="st">"measure"</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">value</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_histogram.html">geom_histogram</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_vline</a></span><span class="op">(</span>xintercept <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html">scale_x_log10</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_grid.html">facet_grid</a></span><span class="op">(</span>rows <span class="op">=</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/vars.html">vars</a></span><span class="op">(</span><span class="va">measure</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p><img src="v02-scp_files/figure-html/qvalue_plot-1.png" width="700"></p>
<p>Filtering out low-confidence PSMs is performed using the <code>filterFeatures</code> function. The SCoPE2 authors removed features so to control a 1% PSM and protein FDR.</p>
<p><strong>Exercise:</strong> Keep only PSMs that have a PSM q-values <strong>and</strong> protein q-values lower than 0.01.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-filtering.html">filterFeatures</a></span><span class="op">(</span><span class="va">scp</span>,
                      <span class="op">~</span> <span class="va">qvalue_psm</span> <span class="op">&lt;</span> <span class="fl">0.01</span> <span class="op">&amp;</span> <span class="va">qvalue_protein</span> <span class="op">&lt;</span> <span class="fl">0.01</span><span class="op">)</span></code></pre></div>
</details>
</div>
<div id="filter-out-contaminants" class="section level3">
<h3 class="hasAnchor">
<a href="#filter-out-contaminants" class="anchor"></a>Filter out contaminants</h3>
<p>All MS-based proteomic experiment is subjected to contamination from the environment. The most common contamination is keratin released from the researcher’s skin. A small database of known contaminants is commonly supplied to tag PSMs originating from potential contaminants. Next to that, a decoy database consisting of reversed peptide sequence is used to assess the reliability of the PSM identification and tag false hits.</p>
<p><strong>Exercise</strong>: remove the PSMs that were matched to contaminant proteins (the protein name starts with <code>CON</code>) or to the decoy database (the protein name starts with <code>REV</code>). Again, <code>filterFeatures</code> can directly access the protein names from the <code>rowData</code>.</p>
<details><summary>
Hint1
</summary>
Remember the <code>rowData</code> column holding the protein names is called <code>protein</code>. You can have a quick look at all protein names using <code>rbindRowData(scp)$protein</code>.
</details><details><summary>
Hint2
</summary>
You can use the <code>grepl</code> function to match protein identifiers with the pattern of interest (<code>REV|CON</code> in this case).
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-filtering.html">filterFeatures</a></span><span class="op">(</span><span class="va">scp</span>,
                      <span class="op">~</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/grep.html">grepl</a></span><span class="op">(</span><span class="st">"REV|CON"</span>, <span class="va">protein</span><span class="op">)</span><span class="op">)</span></code></pre></div>
</details>
</div>
<div id="filter-out-noisy-spectra" class="section level3">
<h3 class="hasAnchor">
<a href="#filter-out-noisy-spectra" class="anchor"></a>Filter out noisy spectra</h3>
<p>A PIF (parental ion fraction) smaller than 80 % indicates the associated spectra is contaminated by co-isolated peptides and therefore the quantification becomes unreliable. The PIF was computed by MaxQuant and is readily available for filtering.</p>
<p><strong>Exercise</strong>: Keep only PSMs that have low spectral contamination, that is, PSMs with an associated PIF greater than 0.8.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-filtering.html">filterFeatures</a></span><span class="op">(</span><span class="va">scp</span>,
                      <span class="op">~</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">PIF</span><span class="op">)</span> <span class="op">&amp;</span> <span class="va">PIF</span> <span class="op">&gt;</span> <span class="fl">0.8</span><span class="op">)</span></code></pre></div>
</details>
</div>
<div id="filter-out-psms-with-high-sample-to-carrier-ratio" class="section level3">
<h3 class="hasAnchor">
<a href="#filter-out-psms-with-high-sample-to-carrier-ratio" class="anchor"></a>Filter out PSMs with high sample to carrier ratio</h3>
<p>The SCoPE2 authors suggested in their paper a new QC metric for SCP data, the sample to carrier ratio (SCR). The SCR is the TMT ion intensity of a single-cell sample divided by the TMT ion intensity of the carrier (200 cells) acquired during the same run as the sample. It is expected that the carrier intensities are much higher than the single-cell intensities. The <code>scp</code> package offers the <code>computeSCR</code> function that computes the SCR for each PSM averaged over all samples of interest in a given assay. To perform this, you need to tell the function which columns are the samples of interest and which columns are the carriers. The <code>colData</code> of the <code>QFeatures</code> object is used to define this.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">scp</span><span class="op">$</span><span class="va">SampleType</span><span class="op">)</span>
<span class="co">## </span>
<span class="co">##      Blank    Carrier Macrophage   Monocyte  Reference     Unused </span>
<span class="co">##         22         24        192         74         24         48</span></code></pre></div>
<p>In this dataset, <code>SampleType</code> gives the type of sample that is present in each TMT channel. The SCoPE2 protocol includes 5 types of samples:</p>
<ul>
<li>The carrier channels (<code>Carrier</code>) contain 200 cell equivalents and are meant to boost the peptide identification rate.</li>
<li>The normalization channels (<code>Reference</code>) contain 5 cell equivalents and are used to partially correct for between-run variation.</li>
<li>The unused channels (<code>Unused</code>) are channels that are left empty due to isotopic cross-contamination by the carrier channel.</li>
<li>The blank channels (<code>Blank</code>) contain samples that do not contain any cell but are processed as single-cell samples.</li>
<li>The single-cell sample channels contain the single-cell samples of interest (<code>Macrophage</code> or <code>Monocyte</code>).</li>
</ul>
<p>The <code>computeSCR</code> function expects the user to provide a pattern (following regular expression syntax) that identifies a carrier channel in each run and the samples. The function will store the computed SCR of each feature in the <code>rowData</code> of the corresponding assay. When multiple matches are found for samples or carrier, you should also provide a summarizing function through <code>sampleFUN</code> and <code>carrierFUN</code> respectively.</p>
<p><strong>Exercise</strong>: Compute the SCR by considering blanks, monocytes and macrophages as samples of interest. Note there are therefore multiple samples per run for each PSM. You should compute the mean of the samples. There is only a single carrier, so you don’t need to bother providing <code>carrierFUN</code>. The SCR is stored in the <code>rowData</code>, call the new variable</p>
<details><summary>
Hint
</summary>
Remember that the sample types are available from the <code>colData</code> column <code>SampleType</code>. The output above provides an overview of the available sample types in the data.
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/computeSCR.html">computeSCR</a></span><span class="op">(</span><span class="va">scp</span>,
                  i <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span>,
                  colvar <span class="op">=</span> <span class="st">"SampleType"</span>,
                  carrierPattern <span class="op">=</span> <span class="st">"Carrier"</span>,
                  samplePattern <span class="op">=</span> <span class="st">"Blank|Monocyte|Macrophage"</span>,
                  sampleFUN <span class="op">=</span> <span class="va">mean</span>,
                  rowDataName <span class="op">=</span> <span class="st">"MeanSCR"</span><span class="op">)</span></code></pre></div>
</details><p>Before applying the filter, let’s plot the distribution of the mean SCR.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-class.html">rbindRowData</a></span><span class="op">(</span><span class="va">scp</span>, i <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="va">data.frame</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">MeanSCR</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_histogram.html">geom_histogram</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_vline</a></span><span class="op">(</span>xintercept <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="fl">200</span>, <span class="fl">0.1</span><span class="op">)</span>,
               lty <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html">scale_x_log10</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<p><img src="v02-scp_files/figure-html/meanSCR_plot-1.png" width="700"></p>
<p>A great majority of the PSMs have a mean SCR that is lower than 10%, as expected. Interestingly, the mode of the distribution is located close to 1%. This is expected since every sample channel contains a single-cell and the carrier contains 200 cells leading to an expected ratio of 0.5% (dashed line).</p>
<p>Note that some of the SCR values are missing (when quantification data are missing or when dividing zero by zero) or are infinite (when carrier is zero but not samples). The features associated to those artefacts are removed as well.</p>
<p><strong>Exercise</strong>: remove the PSMs for which the mean SCR exceeds the 10% threshold. Make sure also to remove mean SCR values that are <code>NA</code> or infinite.</p>
<details><summary>
Hint
</summary>
You can check whether the mean SCR is NA using <code><a href="https://rdrr.io/r/base/NA.html">is.na(MeanSCR)</a></code>, and similarly <code><a href="https://rdrr.io/r/base/is.finite.html">is.infinite(MeanSCR)</a></code> for infinite values.
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-filtering.html">filterFeatures</a></span><span class="op">(</span><span class="va">scp</span>,
                      <span class="op">~</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">MeanSCR</span><span class="op">)</span> <span class="op">&amp;</span>
                          <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/is.finite.html">is.infinite</a></span><span class="op">(</span><span class="va">MeanSCR</span><span class="op">)</span> <span class="op">&amp;</span>
                          <span class="va">MeanSCR</span> <span class="op">&lt;</span> <span class="fl">0.1</span><span class="op">)</span></code></pre></div>
</details>
</div>
</div>
<div id="normalization-to-reference" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization-to-reference" class="anchor"></a>Normalization to reference</h2>
<p>In order to partially correct for between-run variation, the SCoPE2 authors compute relative reporter ion intensities. This means that intensities measured for single-cells are divided by the reference channel (5-cell equivalents). You can use the <code>divideByReference</code> function that divides channels of interest by the reference channel. Similarly to <code>computeSCR</code>, you can point to the samples and the reference columns in each assay using the annotation contained in the <code>colData</code>.</p>
<p><strong>Exercise</strong>: divide all columns by the reference channel using <code>divideByReference</code>.</p>
<details><summary>
Hint
</summary>
You can use the regular expression wildcard <code>.</code> to select all columns.
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/divideByReference.html">divideByReference</a></span><span class="op">(</span><span class="va">scp</span>,
                         i <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span>,
                         colvar <span class="op">=</span> <span class="st">"SampleType"</span>,
                         samplePattern <span class="op">=</span> <span class="st">"."</span>,
                         refPattern <span class="op">=</span> <span class="st">"Reference"</span><span class="op">)</span></code></pre></div>
</details><p>Notice that by taking all samples you also included the reference channel itself. Hence, from now on, the reference channels will contain only ones. This is how it was done in the SCoPE2 paper, but for later analysis, we advice to use a pattern that matches only the single-cell columns.</p>
</div>
<div id="psm-to-peptide-aggregation" class="section level2">
<h2 class="hasAnchor">
<a href="#psm-to-peptide-aggregation" class="anchor"></a>PSM to peptide aggregation</h2>
<p>Now that the PSM assays are processed, you can aggregate them to peptides. This is performed using the <code>aggregateFeaturesOverAssays</code> function. This is a wrapper function in <code>scp</code> that sequentially calls the <code>aggregateFeatures</code> from the <code>QFeatures</code> package over the different assays. For each assay, the function aggregates several PSMs into a unique peptide given an aggregating variable in the <code>rowData</code> (peptide sequence) and a user-supplied aggregating function (the median for instance). Regarding the aggregating function, the SCoPE2 analysis removes duplicated peptide sequences per run by taking the first non-missing value. While better alternatives are documented in <code><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-aggregate.html">QFeatures::aggregateFeatures</a></code>, we suggest to use this approach for the sake of replication, but also to illustrate that custom functions can be applied when aggregating.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">remove.duplicates</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span>
    <span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">x</span>, <span class="fl">2</span>, <span class="kw">function</span><span class="op">(</span><span class="va">xx</span><span class="op">)</span> <span class="va">xx</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.html">which</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span><span class="op">(</span><span class="va">xx</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">)</span></code></pre></div>
<p>For each assay, a new aggregated assay will be added to the dataset. The aggregated peptide assays must be given a name. We here suggest to use the original names prefixed with <code>peptides_</code>.</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">peptideAssays</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html">paste0</a></span><span class="op">(</span><span class="st">"peptides_"</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>You now have all the required information to aggregate the PSMs in the different batches to peptides.</p>
<p><strong>Exercise</strong>: use the <code>aggregateFeaturesOverAssays</code> function to aggregate PSMs to peptides. Don’t forget to provide the <code>remove.duplicates</code> as an aggregating function.</p>
<details><summary>
Hint
</summary>
You should aggregate PSMs to peptides. So, you can group the PSMs by supplying <code>fcol = "peptide"</code>. The function will take the <code>peptide</code> column in the <code>rowData</code> that contains the peptide sequences and create a new aggregated feature for each unique sequence.
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/aggregateFeaturesOverAssays.html">aggregateFeaturesOverAssays</a></span><span class="op">(</span><span class="va">scp</span>,
                                   i <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">scp</span><span class="op">)</span>,
                                   fcol <span class="op">=</span> <span class="st">"peptide"</span>,
                                   name <span class="op">=</span> <span class="va">peptideAssays</span>,
                                   fun <span class="op">=</span> <span class="va">remove.duplicates</span><span class="op">)</span></code></pre></div>
</details><p>Under the hood, the <code>QFeatures</code> architecture preserves the relationship between the aggregated assays. See <code><a href="https://rdrr.io/pkg/QFeatures/man/AssayLinks.html">?AssayLinks</a></code> for more information on relationships between assays. Notice that <code>aggregateFeaturesOverAssays</code> created as many new assays as the number of supplied assays.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">## An instance of class QFeatures containing 48 assays:</span>
<span class="co">##  [1] 190913S_LCB3_X_16plex_Set_12: SingleCellExperiment with 1620 rows and 16 columns </span>
<span class="co">##  [2] 190913S_LCB3_X_16plex_Set_17_reinject2: SingleCellExperiment with 1482 rows and 16 columns </span>
<span class="co">##  [3] 190914S_LCB3_X_16plex_Set_1: SingleCellExperiment with 1415 rows and 16 columns </span>
<span class="co">##  ...</span>
<span class="co">##  [46] peptides_190914S_LCB3_X_16plex_Set_7: SingleCellExperiment with 1771 rows and 16 columns </span>
<span class="co">##  [47] peptides_190914S_LCB3_X_16plex_Set_8: SingleCellExperiment with 1348 rows and 16 columns </span>
<span class="co">##  [48] peptides_190914S_LCB3_X_16plex_Set_9: SingleCellExperiment with 1944 rows and 16 columns</span></code></pre></div>
<p>You can also have a graphical overview of the assay relationships thanks to the <code>plot</code> function. Since many assays are present, we suggested to enable the interactive viewer for you to explore the plot.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">scp</span>, interactive <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
</div>
<div id="cleaning-missing-data" class="section level2">
<h2 class="hasAnchor">
<a href="#cleaning-missing-data" class="anchor"></a>Cleaning missing data</h2>
<p>The next step is to replace zero and infinite values by <code>NA</code>s. The zeros can be biological zeros or technical zeros and differentiating between the two types is a difficult task, they are therefore better considered as missing data that should be modelled using dedicated methods. The infinite values appear during the normalization by the reference when the reference channel is zero. This artefact could easily be avoided if we had replaced the zeros by <code>NA</code>s at the beginning of the workflow, what we strongly recommend for future analyses.</p>
<p>The <code>infIsNA</code> and the <code>zeroIsNA</code> functions automatically detect infinite and zero values, respectively, and replace them with <code>NA</code>s. Those two functions are provided by the <code>QFeatures</code> package. See here how you can replace infinite values by NA:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/is.finite.html">is.infinite</a></span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span>, <span class="va">peptideAssays</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="co">## [1] 31</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-missing-data.html">infIsNA</a></span><span class="op">(</span><span class="va">scp</span>, i <span class="op">=</span> <span class="va">peptideAssays</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/is.finite.html">is.infinite</a></span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span>, <span class="va">peptideAssays</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="co">## [1] 0</span></code></pre></div>
<p><strong>Exercise</strong>: your turn, replace all zero values by NA.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span>, <span class="va">peptideAssays</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">==</span> <span class="fl">0</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">## [1] 1138</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-missing-data.html">zeroIsNA</a></span><span class="op">(</span><span class="va">scp</span>, i <span class="op">=</span> <span class="va">peptideAssays</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span>, <span class="va">peptideAssays</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">==</span> <span class="fl">0</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">## [1] 0</span></code></pre></div>
</details>
</div>
<div id="join-the-peptide-assays-in-one-assay" class="section level2">
<h2 class="hasAnchor">
<a href="#join-the-peptide-assays-in-one-assay" class="anchor"></a>Join the peptide assays in one assay</h2>
<p>Up to now, the data belonging to each MS run are kept in separate assays. You can combine all batches into a single assay using the <code>joinAssays</code> function from the <code>QFeatures</code> package.</p>
<p><strong>Exercise</strong>: use <code>joinAssays</code> to combine all peptide assays in a single assay. Recall that we already stored the peptide assay names in a variable, <code>peptideAssays</code>.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/joinAssays.html">joinAssays</a></span><span class="op">(</span><span class="va">scp</span>,
                  i <span class="op">=</span> <span class="va">peptideAssays</span>,
                  name <span class="op">=</span> <span class="st">"peptides"</span><span class="op">)</span></code></pre></div>
</details><p>Note <code>joinAssays</code> has created a new assay called <code>peptides</code> that combines the previously aggregated peptide assays.</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span>
<span class="co">## An instance of class QFeatures containing 49 assays:</span>
<span class="co">##  [1] 190913S_LCB3_X_16plex_Set_12: SingleCellExperiment with 1620 rows and 16 columns </span>
<span class="co">##  [2] 190913S_LCB3_X_16plex_Set_17_reinject2: SingleCellExperiment with 1482 rows and 16 columns </span>
<span class="co">##  [3] 190914S_LCB3_X_16plex_Set_1: SingleCellExperiment with 1415 rows and 16 columns </span>
<span class="co">##  ...</span>
<span class="co">##  [47] peptides_190914S_LCB3_X_16plex_Set_8: SingleCellExperiment with 1348 rows and 16 columns </span>
<span class="co">##  [48] peptides_190914S_LCB3_X_16plex_Set_9: SingleCellExperiment with 1944 rows and 16 columns </span>
<span class="co">##  [49] peptides: SingleCellExperiment with 4360 rows and 384 columns</span></code></pre></div>
<p>At this point, you can regularly have a look at <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot(scp, interactive = TRUE)</a></code> to keep an overview of the assay hierarchy.</p>
</div>
<div id="single-cell-quality-control" class="section level2">
<h2 class="hasAnchor">
<a href="#single-cell-quality-control" class="anchor"></a>Single-cell quality control</h2>
<p>The SCoPE2 workflow proceeds with the filtering of low quality cells. The filtering is based on the median coefficient of variation (CV) per cell. The CV is measured for each protein in each sample as the standard deviation of the corresponding peptides divided by the average expression of those peptides. Taking the median CV per cell will give a measure of the consistency of the quantification within that cell. We want to remove cells that exhibit a high median CV because inconsistent measure imply artefacts during samples preparation.</p>
<p>For sake of time, we immediately show how to compute the median CV per cell. This is performed using the<br><code>medianCVperCell</code> function from the <code>scp</code> package. The function takes the protein information from the <code>rowData</code> of the assays. This information will tell how to group the features (peptides) when computing the CV. Note that we supply the peptide assays before joining in a single assays (<code>i = peptideAssays</code>). This is because SCoPE2 performs a custom normalization (<code>norm = "SCoPE2"</code>). Each row in an assay is normalized by a scaling factor. This scaling factor is the row mean after dividing the columns by the median. The authors retained CVs that are computed using at least 6 peptides (<code>nobs = 6</code>). See the methods section in <span class="citation">Specht et al. (2021)</span> for more information.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/medianCVperCell.html">medianCVperCell</a></span><span class="op">(</span><span class="va">scp</span>,
                       i <span class="op">=</span> <span class="va">peptideAssays</span>,
                       groupBy <span class="op">=</span> <span class="st">"protein"</span>,
                       nobs <span class="op">=</span> <span class="fl">6</span>,
                       na.rm <span class="op">=</span> <span class="cn">TRUE</span>,
                       colDataName <span class="op">=</span> <span class="st">"MedianCV"</span>,
                       norm <span class="op">=</span> <span class="st">"SCoPE2"</span><span class="op">)</span></code></pre></div>
<p>The computed CVs are stored in the <code>colData</code>. We can now filter cells that have reliable quantifications. The blank samples are not expected to have reliable quantifications and hence can be used to estimate a null distribution of the CV. This distribution helps defining a threshold that filters out single-cells that contain noisy quantification.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">colData</span><span class="op">(</span><span class="va">scp</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="va">data.frame</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">SampleType</span> <span class="op">%in%</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Macrophage"</span>,  <span class="st">"Monocyte"</span>, <span class="st">"Blank"</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">MedianCV</span>,
               fill <span class="op">=</span> <span class="va">SampleType</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_histogram.html">geom_histogram</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_abline.html">geom_vline</a></span><span class="op">(</span>xintercept <span class="op">=</span> <span class="fl">0.365</span><span class="op">)</span></code></pre></div>
<p><img src="v02-scp_files/figure-html/medianCV_plot-1.png" width="700"></p>
<p>We can see that the protein quantification for single-cells are much more consistent within single-cell channels than within blank channels. A threshold of 0.365 best separates single-cells from empty channels.</p>
<p><strong>Exercise</strong>: keep the cells that pass the median CV threshold of 0.365. You should also keep macrophages and monocytes as those represent the samples of interest. You can easily achieve this by subsetting the samples based on the associated <code>colData</code> using the <code>subsetByColData</code> function from the <code>MultiAssayExperiment</code> package on which the <code>QFeatures</code> class depends on.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu">subsetByColData</span><span class="op">(</span><span class="va">scp</span>, 
                       <span class="va">scp</span><span class="op">$</span><span class="va">MedianCV</span> <span class="op">&lt;</span> <span class="fl">0.365</span> <span class="op">&amp;</span>
                           <span class="va">scp</span><span class="op">$</span><span class="va">SampleType</span> <span class="op">%in%</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Macrophage"</span>, <span class="st">"Monocyte"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
</details>
</div>
<div id="normalization" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization" class="anchor"></a>Normalization</h2>
<p>Although you already normalized by the reference channels, the authors of SCoPE2 suggested to proceed with further data normalization. First, they normalize the columns (samples) of the peptide data by the median intensities. Then, the rows (peptides) are normalized by dividing the relative intensities by the mean relative intensities.</p>
<p><strong>Exercise</strong>: apply the first normalization using the <code>normalizeSCP</code> function.</p>
<details><summary>
Hint
</summary>
You will need to use the <code>div.median</code> method. See the <code><a href="https://rdrr.io/pkg/MsCoreUtils/man/normalize.html">MsCoreUtils::normalizeMethods</a></code> documentation for more information.
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Scale column with median</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/normalizeSCP.html">normalizeSCP</a></span><span class="op">(</span><span class="va">scp</span>,
                    i <span class="op">=</span> <span class="st">"peptides"</span>,
                    method <span class="op">=</span> <span class="st">"div.median"</span>,
                    name <span class="op">=</span> <span class="st">"peptides_norm1"</span><span class="op">)</span></code></pre></div>
</details><summary>
Solution
</summary><div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-missing-data.html">filterNA</a></span><span class="op">(</span><span class="va">scp</span>,
                i <span class="op">=</span> <span class="st">"peptides_norm2"</span>,
                pNA <span class="op">=</span> <span class="fl">0.99</span><span class="op">)</span></code></pre></div>

</div>
<div id="log-transformation" class="section level2">
<h2 class="hasAnchor">
<a href="#log-transformation" class="anchor"></a>Log-transformation</h2>
<p>The last processing step of the peptide data before aggregating to proteins is to log-transform the data.</p>
<p><strong>Exercise</strong>: perform a base 2 log-transformation of the normalized data using the <code>logTransform</code> from <code>QFeatures</code>.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-processing.html">logTransform</a></span><span class="op">(</span><span class="va">scp</span>,
                    base <span class="op">=</span> <span class="fl">2</span>,
                    i <span class="op">=</span> <span class="st">"peptides_norm2"</span>,
                    name <span class="op">=</span> <span class="st">"peptides_log"</span><span class="op">)</span></code></pre></div>
</details>
</div>
<div id="peptide-to-protein-aggregation" class="section level2">
<h2 class="hasAnchor">
<a href="#peptide-to-protein-aggregation" class="anchor"></a>Peptide to protein aggregation</h2>
<p>Similarly to aggregating PSM data to peptide data, you can aggregate peptide data to protein data.</p>
<p><strong>Exercise</strong>: aggregate peptides to proteins. Note this time, you can use the <code>aggregateFeatures</code> function instead of the <code>aggregateFeaturesOverAssays</code> function since you only need to aggregate only one assay (<code>peptides_log</code>). You can use the column median as a summarizing function.</p>
<details><summary>
Hint
</summary>
The function should take a matrix-like object as input and return a vector of length equal to the number of columns. The <code><a href="https://rdrr.io/pkg/matrixStats/man/rowMedians.html">matrixStats::colMedians</a></code> function is the function you are looking for.
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-aggregate.html">aggregateFeatures</a></span><span class="op">(</span><span class="va">scp</span>,
                         i <span class="op">=</span> <span class="st">"peptides_log"</span>,
                         name <span class="op">=</span> <span class="st">"proteins"</span>,
                         fcol <span class="op">=</span> <span class="st">"protein"</span>,
                         fun <span class="op">=</span> <span class="fu">matrixStats</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/matrixStats/man/rowMedians.html">colMedians</a></span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
</details>
</div>
<div id="normalization-1" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization-1" class="anchor"></a>Normalization</h2>
<p>Normalization is performed similarly to peptide normalization. You can use the same functions, but since the data were log-transformed at the peptide level, you should subtract/center by the statistic (median or mean) instead of dividing.</p>
<p><strong>Exercise</strong>: normalize the protein data by first median centering the columns followed by mean centering the rows.</p>
<details><summary>
Hint
</summary>
Have a look at what we did for peptide normalization. Instead of dividing, you should subtract.
</details><details><summary>
Solution
</summary><div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Center columns with median</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/normalizeSCP.html">normalizeSCP</a></span><span class="op">(</span><span class="va">scp</span>,
                    i <span class="op">=</span> <span class="st">"proteins"</span>,
                    method <span class="op">=</span> <span class="st">"center.median"</span>,
                    name <span class="op">=</span> <span class="st">"proteins_norm1"</span><span class="op">)</span>
<span class="co">## Center rows with mean</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-processing.html">sweep</a></span><span class="op">(</span><span class="va">scp</span>,
             i <span class="op">=</span> <span class="st">"proteins_norm1"</span>,
             MARGIN <span class="op">=</span> <span class="fl">1</span>,
             FUN <span class="op">=</span> <span class="st">"-"</span>,
             STATS <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_norm1"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>,
                              na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
             name <span class="op">=</span> <span class="st">"proteins_norm2"</span><span class="op">)</span></code></pre></div>
</details>
</div>
<div id="imputation" class="section level2">
<h2 class="hasAnchor">
<a href="#imputation" class="anchor"></a>Imputation</h2>
<p>The protein data contains a lot of missing values. Let’s have a look at the distribution of the percent missing data per sample. You can easily achieve this by using the <code>nNA</code> function. Cells contain on average over 75% missing values!</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">nNAres</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-missing-data.html">nNA</a></span><span class="op">(</span><span class="va">scp</span>, <span class="st">"proteins_norm2"</span><span class="op">)</span><span class="op">$</span><span class="va">nNAcols</span>
<span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span><span class="va">nNAres</span><span class="op">)</span>,
       <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">pNA</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_histogram.html">geom_histogram</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<p><img src="v02-scp_files/figure-html/missing_plot-1.png" width="700"></p>
<p>The missing data is imputed using K nearest neighbors. <code>QFeatures</code> provides the <code>impute</code> function that serves as an interface to different imputation algorithms among which the KNN algorithm from <code><a href="https://rdrr.io/pkg/impute/man/impute.knn.html">impute::impute.knn</a></code>.</p>
<p><strong>Exercise</strong>: impute the missing the data using the KNN imputation algorithm. You can arbitrarily set K = 3.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/impute.html">impute</a></span><span class="op">(</span><span class="va">scp</span>,
              i <span class="op">=</span> <span class="st">"proteins_norm2"</span>,
              method <span class="op">=</span> <span class="st">"knn"</span>,
              k <span class="op">=</span> <span class="fl">3</span>, rowmax <span class="op">=</span> <span class="fl">1</span>, colmax<span class="op">=</span> <span class="fl">1</span>,
              maxp <span class="op">=</span> <span class="cn">Inf</span>, rng.seed <span class="op">=</span> <span class="fl">1234</span><span class="op">)</span></code></pre></div>
</details>
</div>
<div id="batch-correction" class="section level2">
<h2 class="hasAnchor">
<a href="#batch-correction" class="anchor"></a>Batch correction</h2>
<p>The final step is to model the remaining batch effects and correct for it. The data were acquired as a series of MS runs. Each MS run can be subjected to technical perturbations that lead to differences in the data. This must be accounted for to avoid attributing biological effects to technical effects. The <code>ComBat</code> algorithm (<span class="citation">Johnson, Li, and Rabinovic (2007)</span>) is used in the SCoPE2 script to correct for those batch effects. <code>ComBat</code> is part of the <code>sva</code> package. It requires a batch variable, in this case the LC-MS/MS run, and adjusts for batch effects, while protecting variables of interest, the sample type in this case.</p>
<p><strong>Important</strong>: we do not claim <code>ComBat</code> is the best method to model batch effect, we simply follow the SCoPE2 workflow. Therefore, we do not provide a wrapper function for applying batch correction on <code>QFeatures</code> object. However, this section is an excellent example on how to apply custom functions to the data.</p>
<p>Let’s first extract the assays with the associated <code>colData</code>.</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu">getWithColData</span><span class="op">(</span><span class="va">scp</span>, <span class="st">"proteins_norm2"</span><span class="op">)</span>
<span class="co">## Warning: 'experiments' dropped; see 'metadata'</span></code></pre></div>
<p>You can then apply the function of interest, here batch correction with <code>ComBat</code>. See how we easily retrieve the sample annotation required to perform the batch correction. The output of <code>ComBat</code> is used to overwrite the data in the assay.</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">batch</span> <span class="op">&lt;-</span> <span class="va">sce</span><span class="op">$</span><span class="va">Set</span>
<span class="va">model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/model.matrix.html">model.matrix</a></span><span class="op">(</span><span class="op">~</span> <span class="va">SampleType</span>, data <span class="op">=</span> <span class="fu">colData</span><span class="op">(</span><span class="va">sce</span><span class="op">)</span><span class="op">)</span>
<span class="fu">assay</span><span class="op">(</span><span class="va">sce</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">ComBat</span><span class="op">(</span>dat <span class="op">=</span> <span class="fu">assay</span><span class="op">(</span><span class="va">sce</span><span class="op">)</span>,
                     batch <span class="op">=</span> <span class="va">batch</span>,
                     mod <span class="op">=</span> <span class="va">model</span><span class="op">)</span></code></pre></div>
<p>Finally, the modified assay needs to be added to the <code>QFeatures</code> object. To properly achieve this, you will need two functions. First, <code>addAssay</code> allows you to add the new assay to the data set. Second, the <code>addAssayLinkOneToOne</code> will create one-to-one link between the proteins of the new assay and the proteins of a parent assay.</p>
<p><strong>Exercise</strong>: add the batch corrected protein data as a new assay in the <code>QFeatures</code> object (you can call it <code>proteins_batchC</code>). Create a one-to-one relationship between the features of the last assay (<code>proteins_norm2</code>) and the features of the newly added assay.</p>
<details><summary>
Solution
</summary><div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-class.html">addAssay</a></span><span class="op">(</span><span class="va">scp</span>, y <span class="op">=</span> <span class="va">sce</span>,
                name <span class="op">=</span> <span class="st">"proteins_batchC"</span><span class="op">)</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/AssayLinks.html">addAssayLinkOneToOne</a></span><span class="op">(</span><span class="va">scp</span>, from <span class="op">=</span> <span class="st">"proteins_norm2"</span>,
                            to <span class="op">=</span> <span class="st">"proteins_batchC"</span><span class="op">)</span></code></pre></div>
</details><p>Note that in the case the new assay has not a one-to-one relationship with the parent assay, you can also add custom relationships using the <code>addAssayLink</code> function.</p>
</div>
<div id="normalization-2" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization-2" class="anchor"></a>Normalization</h2>
<p>A final normalization step is performed in the SCoPE2 workflow. This is exactly the same as three sections above.</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">## Center columns with median</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://UCLouvain-CBIO.github.io/scp/reference/normalizeSCP.html">normalizeSCP</a></span><span class="op">(</span><span class="va">scp</span>,
                    i <span class="op">=</span> <span class="st">"proteins_batchC"</span>,
                    method <span class="op">=</span> <span class="st">"center.median"</span>,
                    name <span class="op">=</span> <span class="st">"proteins_batchC_norm1"</span><span class="op">)</span>
<span class="co">## Center rows with mean</span>
<span class="va">scp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-processing.html">sweep</a></span><span class="op">(</span><span class="va">scp</span>,
             i <span class="op">=</span> <span class="st">"proteins_batchC_norm1"</span>,
             MARGIN <span class="op">=</span> <span class="fl">1</span>,
             FUN <span class="op">=</span> <span class="st">"-"</span>,
             STATS <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html">rowMeans</a></span><span class="op">(</span><span class="fu">assay</span><span class="op">(</span><span class="va">scp</span><span class="op">[[</span><span class="st">"proteins_batchC_norm1"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>,
                              na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
             name <span class="op">=</span> <span class="st">"proteins_scp"</span><span class="op">)</span></code></pre></div>
<p>By running this last step, you have replicated the data processing performed by the SCoPE2 workflow! The data is now ready for data exploration and downstream analyses.</p>
</div>
</div>
<div id="data-visualization" class="section level1">
<h1 class="hasAnchor">
<a href="#data-visualization" class="anchor"></a>Data visualization</h1>
<p>The <code>QFeatures</code> package provides the <code>longFormat</code> function that formats the data set as a long table, ideal for the integration with <code>ggplot2</code>. This can be used for instance to explore the different processing steps applied to the data. Suppose you have a protein of interest, for instance Filamin-A (<code>P21333</code>). You can subset the <code>QFeatures</code> object with that protein using the first index in the bracket function. Note that the subsetting will select that protein and all associated peptides and PSMs across all assays. Next the <code>QFeatures</code> is converted to a long table, containing the quantitative values, but also some variables of interest from the <code>colData</code> (<code>colvars</code>) and the <code>rowData</code> (<code>rowvars</code>). We can use the metadata to filter for a batch of interest for example.</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lf</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/QFeatures/man/QFeatures-class.html">longFormat</a></span><span class="op">(</span><span class="va">scp</span><span class="op">[</span><span class="st">"P21333"</span>, , <span class="op">]</span>,
                 colvars <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Set"</span>, <span class="st">"Channel"</span>, <span class="st">"SampleType"</span><span class="op">)</span><span class="op">)</span>
<span class="va">lf</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span><span class="va">lf</span><span class="op">)</span>, <span class="va">Set</span> <span class="op">==</span> <span class="st">"190913S_LCB3_X_16plex_Set_12"</span><span class="op">)</span></code></pre></div>
<p>This filtered long data is then passed to <code>ggplot2</code> for data visualization.</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html">ggplot</a></span><span class="op">(</span><span class="va">lf</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">Channel</span>, 
        y <span class="op">=</span> <span class="va">value</span>,
        col <span class="op">=</span> <span class="va">SampleType</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html">geom_point</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html">facet_wrap</a></span><span class="op">(</span><span class="op">~</span> <span class="va">assay</span>, scales <span class="op">=</span> <span class="st">"free"</span><span class="op">)</span> <span class="op">+</span>
    <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/theme.html">theme</a></span><span class="op">(</span>axis.text.x <span class="op">=</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/element.html">element_text</a></span><span class="op">(</span>angle <span class="op">=</span> <span class="fl">90</span><span class="op">)</span><span class="op">)</span>
<span class="co">## Warning: Removed 1262 rows containing missing values (geom_point).</span></code></pre></div>
<p><img src="v02-scp_files/figure-html/unnamed-chunk-34-1.png" width="960"></p>
<p>This graph can be used to track the processing of the quantitative data.</p>
<p>Since each assay is a <code>SingleCellExperiment</code> object, the data can also easily be plugged into dimension reduction functions from the Bioconductor package <code>scater</code>. We show here an example of dimension reduction results using t-SNE.</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu">getWithColData</span><span class="op">(</span><span class="va">scp</span>, <span class="st">"proteins_scp"</span><span class="op">)</span>
<span class="co">## Warning: 'experiments' dropped; see 'metadata'</span>
<span class="co">## Warning: Ignoring redundant column names in 'colData(x)':</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://bioconductor.org/packages/scater/">scater</a></span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span>
<span class="va">sce</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/scater/man/runTSNE.html">runTSNE</a></span><span class="op">(</span><span class="va">sce</span>, 
               ncomponents <span class="op">=</span> <span class="fl">2</span>,
               ntop <span class="op">=</span> <span class="cn">Inf</span>,
               scale <span class="op">=</span> <span class="cn">TRUE</span>,
               exprs_values <span class="op">=</span> <span class="fl">1</span>,
               name <span class="op">=</span> <span class="st">"TSNE"</span><span class="op">)</span> 
<span class="co">## Plotting is performed in a single line of code</span>
<span class="fu"><a href="https://rdrr.io/pkg/scater/man/plot_reddim.html">plotTSNE</a></span><span class="op">(</span><span class="va">sce</span>, colour_by <span class="op">=</span> <span class="st">"SampleType"</span><span class="op">)</span></code></pre></div>
<p><img src="v02-scp_files/figure-html/unnamed-chunk-35-1.png" width="700"></p>
<p>This graph shows a low dimension representation of the final processed protein data. Each point represents a cell. The sample type is accessed from the <code>colData</code> and coloured on the graph. This allows to evaluate whether the quantitative data contains information to separate monocytes from differentiated macrophages.</p>
</div>
<div id="conclusion" class="section level1">
<h1 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h1>
<p>We hope we could convince you that <code>QFeatures</code> and its extension <code>scp</code> are an ideal environment to manipulate and process MS-SCP quantification data. This is only the beginning of the journey, as further development and benchmarking are required to offer improved processing workflows. Furthermore, downstream analyses, such as differential expression analyses, require the development of new statistical methods to model the complex data structure present in SCP data (<span class="citation">Vanderaa and Gatto (2021)</span>). Those methods could highly benefit from the <code>QFeatures</code> and <code>scp</code> infrastructure to access and manipulate the required information. Furthermore, the <code>scpdata</code> package provides ready-to-process data that represent valuable use cases to build analytical method onto.</p>
</div>
<div id="further-reading" class="section level1">
<h1 class="hasAnchor">
<a href="#further-reading" class="anchor"></a>Further reading</h1>
<ul>
<li>You can find more information about how to load your own data using <code>scp</code> in <a href="https://uclouvain-cbio.github.io/scp/articles/read_scp.html">this vignette</a>.</li>
<li>We also dedicated a <a href="https://rformassspectrometry.github.io/QFeatures/articles/Visualization.html">separate vignette</a> about data visualization from a <code>QFeatures</code> object.</li>
<li>If you want to push forward the development of new analytical methods and QC metrics in for single-cell proteomics, we also recommend you to read the <a href="https://uclouvain-cbio.github.io/scp/articles/advanced.html">advanced vignette</a>.</li>
</ul>
<p>Have a look at <a href="http://dx.doi.org/10.1101/2021.04.12.439408">our paper</a> that describes the reproduction of the complete SCoPE2 data set and highlights some important challenges that remain to be tackled in the field.</p>
</div>
<div id="session-information" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#session-information" class="anchor"></a>Session information</h1>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/sessionInfo.html">sessionInfo</a></span><span class="op">(</span><span class="op">)</span>
<span class="co">## R version 4.1.0 (2021-05-18)</span>
<span class="co">## Platform: x86_64-pc-linux-gnu (64-bit)</span>
<span class="co">## Running under: Ubuntu 20.04.2 LTS</span>
<span class="co">## </span>
<span class="co">## Matrix products: default</span>
<span class="co">## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so</span>
<span class="co">## </span>
<span class="co">## locale:</span>
<span class="co">##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              </span>
<span class="co">##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    </span>
<span class="co">##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             </span>
<span class="co">##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 </span>
<span class="co">##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            </span>
<span class="co">## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       </span>
<span class="co">## </span>
<span class="co">## attached base packages:</span>
<span class="co">## [1] stats4    stats     graphics  grDevices utils     datasets  methods  </span>
<span class="co">## [8] base     </span>
<span class="co">## </span>
<span class="co">## other attached packages:</span>
<span class="co">##  [1] scater_1.21.2               scuttle_1.3.0              </span>
<span class="co">##  [3] SingleCellExperiment_1.15.1 forcats_0.5.1              </span>
<span class="co">##  [5] stringr_1.4.0               dplyr_1.0.7                </span>
<span class="co">##  [7] purrr_0.3.4                 readr_2.0.0                </span>
<span class="co">##  [9] tidyr_1.1.3                 tibble_3.1.3               </span>
<span class="co">## [11] ggplot2_3.3.5               tidyverse_1.3.1            </span>
<span class="co">## [13] sva_3.41.0                  BiocParallel_1.27.2        </span>
<span class="co">## [15] genefilter_1.75.0           mgcv_1.8-36                </span>
<span class="co">## [17] nlme_3.1-152                scpdata_1.1.0              </span>
<span class="co">## [19] ExperimentHub_2.1.4         AnnotationHub_3.1.4        </span>
<span class="co">## [21] BiocFileCache_2.1.1         dbplyr_2.1.1               </span>
<span class="co">## [23] scp_1.3.3                   QFeatures_1.3.6            </span>
<span class="co">## [25] MultiAssayExperiment_1.19.5 SummarizedExperiment_1.23.1</span>
<span class="co">## [27] Biobase_2.53.0              GenomicRanges_1.45.0       </span>
<span class="co">## [29] GenomeInfoDb_1.29.3         IRanges_2.27.0             </span>
<span class="co">## [31] S4Vectors_0.31.0            BiocGenerics_0.39.1        </span>
<span class="co">## [33] MatrixGenerics_1.5.1        matrixStats_0.60.0         </span>
<span class="co">## [35] BiocStyle_2.21.3           </span>
<span class="co">## </span>
<span class="co">## loaded via a namespace (and not attached):</span>
<span class="co">##   [1] readxl_1.3.1                  backports_1.2.1              </span>
<span class="co">##   [3] systemfonts_1.0.2             igraph_1.2.6                 </span>
<span class="co">##   [5] lazyeval_0.2.2                splines_4.1.0                </span>
<span class="co">##   [7] digest_0.6.27                 htmltools_0.5.1.1            </span>
<span class="co">##   [9] viridis_0.6.1                 fansi_0.5.0                  </span>
<span class="co">##  [11] magrittr_2.0.1                memoise_2.0.0                </span>
<span class="co">##  [13] ScaledMatrix_1.1.0            cluster_2.1.2                </span>
<span class="co">##  [15] tzdb_0.1.2                    limma_3.49.1                 </span>
<span class="co">##  [17] Biostrings_2.61.1             annotate_1.71.0              </span>
<span class="co">##  [19] modelr_0.1.8                  pkgdown_1.6.1                </span>
<span class="co">##  [21] colorspace_2.0-2              blob_1.2.2                   </span>
<span class="co">##  [23] rvest_1.0.1                   rappdirs_0.3.3               </span>
<span class="co">##  [25] textshaping_0.3.5             haven_2.4.1                  </span>
<span class="co">##  [27] xfun_0.24                     crayon_1.4.1                 </span>
<span class="co">##  [29] RCurl_1.98-1.3                jsonlite_1.7.2               </span>
<span class="co">##  [31] impute_1.67.0                 survival_3.2-11              </span>
<span class="co">##  [33] glue_1.4.2                    gtable_0.3.0                 </span>
<span class="co">##  [35] zlibbioc_1.39.0               XVector_0.33.0               </span>
<span class="co">##  [37] DelayedArray_0.19.1           BiocSingular_1.9.1           </span>
<span class="co">##  [39] scales_1.1.1                  DBI_1.1.1                    </span>
<span class="co">##  [41] edgeR_3.35.0                  Rcpp_1.0.7                   </span>
<span class="co">##  [43] viridisLite_0.4.0             xtable_1.8-4                 </span>
<span class="co">##  [45] clue_0.3-59                   rsvd_1.0.5                   </span>
<span class="co">##  [47] bit_4.0.4                     MsCoreUtils_1.5.0            </span>
<span class="co">##  [49] httr_1.4.2                    ellipsis_0.3.2               </span>
<span class="co">##  [51] farver_2.1.0                  pkgconfig_2.0.3              </span>
<span class="co">##  [53] XML_3.99-0.6                  sass_0.4.0                   </span>
<span class="co">##  [55] locfit_1.5-9.4                utf8_1.2.2                   </span>
<span class="co">##  [57] labeling_0.4.2                tidyselect_1.1.1             </span>
<span class="co">##  [59] rlang_0.4.11                  later_1.2.0                  </span>
<span class="co">##  [61] AnnotationDbi_1.55.1          munsell_0.5.0                </span>
<span class="co">##  [63] BiocVersion_3.14.0            cellranger_1.1.0             </span>
<span class="co">##  [65] tools_4.1.0                   cachem_1.0.5                 </span>
<span class="co">##  [67] cli_3.0.1                     generics_0.1.0               </span>
<span class="co">##  [69] RSQLite_2.2.7                 broom_0.7.9                  </span>
<span class="co">##  [71] evaluate_0.14                 fastmap_1.1.0                </span>
<span class="co">##  [73] yaml_2.2.1                    ragg_1.1.3                   </span>
<span class="co">##  [75] knitr_1.33                    bit64_4.0.5                  </span>
<span class="co">##  [77] fs_1.5.0                      KEGGREST_1.33.0              </span>
<span class="co">##  [79] AnnotationFilter_1.17.1       sparseMatrixStats_1.5.0      </span>
<span class="co">##  [81] mime_0.11                     xml2_1.3.2                   </span>
<span class="co">##  [83] compiler_4.1.0                rstudioapi_0.13              </span>
<span class="co">##  [85] beeswarm_0.4.0                filelock_1.0.2               </span>
<span class="co">##  [87] curl_4.3.2                    png_0.1-7                    </span>
<span class="co">##  [89] interactiveDisplayBase_1.31.2 reprex_2.0.0                 </span>
<span class="co">##  [91] bslib_0.2.5.1                 stringi_1.7.3                </span>
<span class="co">##  [93] highr_0.9                     desc_1.3.0                   </span>
<span class="co">##  [95] lattice_0.20-44               ProtGenerics_1.25.1          </span>
<span class="co">##  [97] Matrix_1.3-4                  vctrs_0.3.8                  </span>
<span class="co">##  [99] pillar_1.6.2                  lifecycle_1.0.0              </span>
<span class="co">## [101] BiocManager_1.30.16           jquerylib_0.1.4              </span>
<span class="co">## [103] BiocNeighbors_1.11.0          cowplot_1.1.1                </span>
<span class="co">## [105] irlba_2.3.3                   bitops_1.0-7                 </span>
<span class="co">## [107] httpuv_1.6.1                  R6_2.5.0                     </span>
<span class="co">## [109] promises_1.2.0.1              gridExtra_2.3                </span>
<span class="co">## [111] vipor_0.4.5                   MASS_7.3-54                  </span>
<span class="co">## [113] assertthat_0.2.1              rprojroot_2.0.2              </span>
<span class="co">## [115] withr_2.4.2                   GenomeInfoDbData_1.2.6       </span>
<span class="co">## [117] parallel_4.1.0                hms_1.1.0                    </span>
<span class="co">## [119] beachmat_2.9.0                grid_4.1.0                   </span>
<span class="co">## [121] DelayedMatrixStats_1.15.0     rmarkdown_2.9                </span>
<span class="co">## [123] Rtsne_0.15                    shiny_1.6.0                  </span>
<span class="co">## [125] lubridate_1.7.10              ggbeeswarm_0.6.0</span></code></pre></div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Chen2019-uc" class="csl-entry">
Chen, Albert Tian, Alexander Franks, and Nikolai Slavov. 2019. <span>“<span>DART-ID</span> Increases Single-Cell Proteome Coverage.”</span> <em>PLoS Comput. Biol.</em> 15 (7): e1007082.
</div>
<div id="ref-Johnson2007-nc" class="csl-entry">
Johnson, W Evan, Cheng Li, and Ariel Rabinovic. 2007. <span>“Adjusting Batch Effects in Microarray Expression Data Using Empirical Bayes Methods.”</span> <em>Biostatistics</em> 8 (1): 118–27.
</div>
<div id="ref-Kall2008-hb" class="csl-entry">
Käll, Lukas, John D Storey, Michael J MacCoss, and William Stafford Noble. 2008. <span>“Posterior Error Probabilities and False Discovery Rates: Two Sides of the Same Coin.”</span> <em>J. Proteome Res.</em> 7 (1): 40–44.
</div>
<div id="ref-Kelly2020-xd" class="csl-entry">
Kelly, Ryan T. 2020. <span>“<span>Single-Cell</span> Proteomics: Progress and Prospects.”</span> <em>Mol. Cell. Proteomics</em>, August.
</div>
<div id="ref-Lun2020-cv" class="csl-entry">
Lun, Aaron, and Davide Risso. 2020. <em><span>SingleCellExperiment</span>: <span>S4</span> Classes for Single Cell Data</em>.
</div>
<div id="ref-Specht2021-jm" class="csl-entry">
Specht, Harrison, Edward Emmott, Aleksandra A Petelski, R Gray Huffman, David H Perlman, Marco Serra, Peter Kharchenko, Antonius Koller, and Nikolai Slavov. 2021. <span>“Single-Cell Proteomic and Transcriptomic Analysis of Macrophage Heterogeneity Using <span>SCoPE2</span>.”</span> <em>Genome Biol.</em> 22 (1): 50.
</div>
<div id="ref-Vanderaa2021-xd" class="csl-entry">
Vanderaa, Christophe, and Laurent Gatto. 2021. <span>“Utilizing Scp for the Analysis and Replication of Single-Cell Proteomics Data.”</span> <em>bioRxiv</em>.
</div>
<div id="ref-Zhu2019-ja" class="csl-entry">
Zhu, Ying, Mirko Scheibinger, Daniel Christian Ellwanger, Jocelyn F Krey, Dongseok Choi, Ryan T Kelly, Stefan Heller, and Peter G Barr-Gillespie. 2019. <span>“Single-Cell Proteomics Reveals Changes in Expression During Hair-Cell Development.”</span> <em>Elife</em> 8 (November).
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Laurent Gatto, Christophe Vanderaa.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
